\chapter{Implementation}
\label{chap:num_5}

The following chapter is going to cover the implementation of \lpas{} package, the frontend components as well as the ontology. The first part of the chapter dedicated to the implementation of the package will provide a detailed overview of the decisions made on the development stack, the main challenges invoked in refactoring the original \lpa{} codebase, and making the \solid{} related functionality more generic. The frontend components section will dive deeper into the implementation of the mocks provided in \autoref{chap:num_4}, main decisions, and challenges while developing under React. The ontology section \TODO{link} will describe how the designed \lpas{} vocabulary was converted into a \texttt{.owl} file, converted into \texttt{.jsonld} Schema and later integrated into the \lpa{} frontend. Lastly, an overview of the implementation results will be presented by reiterating over the defined \lpa{} requirements and how they were satisfied by the implementation.
 
\section{Storage Package}

The initial implementation of \lpa{} frontend was written in \texttt{JavaScript ES6} \footnote{http://es6-features.org} and \texttt{React} framework. The development stack also included tools such as \texttt{Babel} \footnote{https://babeljs.io} compiler and \texttt{Webpack} \footnote{https://webpack.js.org} package bundler. As the amount of features and functionality to cover was increasing, the decision was made to separate the \solid{} storage related functionality into a separate \texttt{npm} package and call it \lpas{}. This section will provide an overview of preliminaries chosen for the implementation of \lpas{} package as well as the specifics of implementations of each abstraction defined in \autoref{ssec:storage}. 

\subsection{Preliminaries}

As briefly mentioned earlier, there several main libraries used inside the \lpas{} package:

\begin{itemize}
    \item \texttt{rdflib} is a low-level RDF library, that mainly provides the functionality to Read and Write RDF in many popular formats, a querying store and an ability to use SPARQL queries.
    \item \texttt{solid-auth-client}, a browser library that implements \solid{} specifications for providing authentication. This is the main library used to enable the authentication into \lpa{} platform.    
%    Todo add ref for testing chapter
    \item \texttt{ava.js}, is a simple JavaScript unit tests runner with TypeScript support. More on testing will be described in a Testing chapter. It is important to note that proper unit testing was one of the other major factors for splitting the \solid{} functionality into a separate package. Easier code maintainability, along with features of TypeScript, significantly improved test-driven development of the package. 
    \item \texttt{istanbul.js}, a test coverage tool used along with \texttt{ava.js}. The library provides a convenient command-line interface that was used for improving Continuous Integration and Delivery jobs. More details on CI and CD are covered in the testing chapter.
\end{itemize}

Due to the complexity of the usage of the stated libraries, specifically \texttt{rdflib}, having an environment and a language that provides a fully-featured object-oriented programming and static type-checking would directly affect the code maintainability and usage. Hence, the codebase of \lpas{} was implemented using \texttt{TypeScript} \footnote{https://www.typescriptlang.org}. TypeScript is a strict syntactical superset of JavaScript that provides optional static typing and better object-oriented programming capabilities.  

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{lpas_implementation_transpilation_diagram.png}
\caption{A diagram demonstrating the process of transpilation of \lpas{} package and bundling \lpa{} frontend with Webpack}
\label{fig:lpas_implementation_transpilation_diagram}
\end{figure}

As demonstrated on \autoref{fig:lpas_implementation_transpilation_diagram}, integrating the package into the \lpa{} codebase was done using the TypeScript compiler that allows transpilation into ES6 compatible Javascript syntax. The package, as well as the rest of the \lpa{} codebase,  is later bundled into a set of static assets using Webpack. The assets mainly consist of a set of media files such as \texttt{.png} and \texttt{.svg} files and a large \texttt{.js} file that contain the whole \lpa{} frontend. One of a few disadvantages with that approach is that the initial loading of the frontend might take a few seconds to load in the browser. Afterward, the interaction with the platform is seamless and does not involve any additional loading.

\subsubsection{Project structure}

The structure of the \lpas{} package is simple and straightforward and can be demonstrated as follows:

\begin{lstlisting}
- build       # Transpiled JS code    
- markdown    # Markdown assets
- src         # Root project folder
  - lib       # Main library codebase
    - common  # Utilities and helper functions
   	- ...     # TypeScript tests and core abstractions
  - types     # Custom user-defined type definitions
- docs        # Static html with library documentation
_ ...         # Readme and various configuration files
\end{lstlisting}

The proceeding sections will describe the individual abstractions mentioned in \autoref{ssec:storage} section.

\subsection{Authentication Manager}

This section will continue the architectural description of the Authentication manager described in \autoref{sssec:authentication_manager}, describe the implementation, and provide examples of how the abstraction is used inside \lpa{}.

The \textit{AuthenticationManager} is a Singleton class, instantiated only once and utilised both in the package itself as well as being invoked from \lpa{} frontend codebase. The reason for the class being implemented as a singleton is due to the fact that it wraps the functionality of \texttt{solid-auth-client} library. Aside from providing the WebID authentication,  \texttt{solid-auth-client} implements a WebID OIDC specific \textit{fetch} functionality. The \textit{FETCH API} is originally a JavaScript API that provides an ability to send asynchronous \texttt{HTTP} calls. The implementation in \texttt{solid-auth-client}, is based on \texttt{isomorpic-fetch}, which is a third party framework that implements the \textit{Fetch API} both for browsers and node.js. Hence, the abstraction is used for:
\begin{itemize}
    \item Authentication, and ability to track the user session with callbacks. 
    \item Sending \texttt{HTTP} calls to \solid{} server.
\end{itemize}


\begin{figure}[h]
\centering
\includegraphics[width=6cm]{lpas_authentication_class.png}
\caption{A class diagram generated directly from a TypeScript file, demonstrating an implemented \textit{AuthenticationManager} abstraction}
\label{fig:lpas_authentication_class}
\end{figure}


In other words, once the client is logged in the \solid{} app, consecutive interactions are performed via \textit{fetch} function that is conveniently wrapped in the \textit{AuthenticationManager} abstraction.

As demonstrated on \autoref{fig:lpas_authentication_class}, the class consist of a set of public methods described as follows:
\begin{itemize}
    \item \textit{getInstance()}, this public method returns a singleton instance to an AuthenticationManager.
    \item \textit{fetch()}, a wrapper redirecting the call to \texttt{solid-auth-client} fetch method.
    \item \textit{login()}, a wrapper redirecting the call to \texttt{solid-auth-client} login method.
    \item \textit{trackSession()}, a method with asynchronous callback notifying the listener when a logout or login operation is performed.
    \item \textit{currentSession()}, a method returning the instance of a \texttt{solid-auth-client} Session object that contains relevant information about the authenticated user and his WebID. 
\end{itemize}

Referring back to \autoref{fig:lps_authentication_sequence_diagram}, there are several places in \lpa{} codebase where the \textit{AuthenticationManager} is invoked directly. The implementation of React components will be covered in the proceeding section, but the invocation of the abstraction itself can be described as follows:
\begin{itemize}
    \item \textit{Component layouts} are special high-level react containers that wrap every other container inside \lpa{} frontend. They are differentiated by \textit{public} and \textit{private}. The \textit{private} components reactively monitor the authenticated session of a user and redirect them back to the authentication screen whenever the value of the session becomes \texttt{undefined}. It is important to note that the session object from \textit{AuthenticationManger} is duplicated in \lpa{} frontend as a Redux state. Therefore, any changes in the original session object are reflected on that state and triggers re-rendering of layout components. 
    \item \textit{Authentication component functions}, are the functions being invoked when user attempts to perform the authentication. In other words, this is the input that triggers the flow demonstrated earlier on \autoref{fig:lps_authentication_sequence_diagram}.
    \item \textit{The App router}, the main class in \lpa{} that serves as an entry point and utilizing the \texttt{react-router} \footnote{https://www.npmjs.com/package/react-router} package, contains a function that invokes the \textit{trackSession()} method in \textit{AuthenticationManager}. This directly links to the session object and updates the changes from original session to internal Redux state.
\end{itemize}

The usage of both \textit{currentSession()} and \textit{login()} methods from \textit{AuthenticationManager} can be observed below:
\begin{lstlisting}[language=JavaScript]
login = async (idp, callbackUri) => {
    const session = await AuthenticationManager.currentSession();
    if (!session)
      await AuthenticationManager.login(idp, {
        storage: localStorage
      });
    else {
      Log.info(`Logged in as ${session.webId}`);
      return session;
    }
};
\end{lstlisting}

To sum up, the \textit{AuthenticationManager} is a simple and straightforward singleton abstraction that wraps the \texttt{solid-auth-client} library and only necessary functions from the wrapped library to be used inside \lpas{} frontend. The examples of invocation from within the \lpas{} package are limited to directly calling the \textit{fetch()} method whenever an \texttt{HTTP} request is assembled and needs to be executed, more details on that will be described in a section dedicated to \textit{FileManager} abstraction.  


%\subsubsection{Creating resources}
%\subsubsection{Reading resources}
%\subsubsection{Renaming resources}
%\subsubsection{Deleting resources}

\subsection{File Manager}

In this subsection, we will continue on the \textit{FileManager} abstraction described in \autoref{sssec:file_manager}, provide the specifics on implementation as well as a detailed overview of each method inside the abstraction.  

\begin{figure}[h]
\centering
\includegraphics[width=5cm]{lpas_implementation_file_manager_diagram.png}
\caption{A class diagram generated directly from a TypeScript file, demonstrating an implemented \textit{FileManager} abstraction}
\label{fig:lpas_filemanager_implementation_class}
\end{figure}

Similar to the \textit{AuthenticationManager}, the \textit{FileManager} abstraction is implemented as a TypeScript class providing a set of public static methods. It is responsible for all core \textit{CRUD} operations with \solid{} resources. It is important to note that all \texttt{HTTP} requests to \solid{} server are made using the \textit{fetch()} method invoked via \textit{AuthenticationManager}. In other words \textit{FileManager} relies on \textit{AuthenticationManager} when performing \texttt{HTTP} requests. To follow up a class representation on \autoref{fig:lpas_filemanager_implementation_class}, the methods can be described as follows:
\begin{itemize}
%    \item \textit{updateACL}, a function is responsible for applying changes to existing \texttt{ACL} files. For instance, changes access privileges for a specific user, or adding a new member to access a resource by his WebID. This function is closely related to \textit{Access Control Manager}
%    \item \textit{createACL}, a function is responsible for creating a new \texttt{Acce}
    \item \textit{createResource()}, a function is responsible for creating new \solid{} resources. 
    \item \textit{deleteFolderContents()}, a function is mainly used for cleaning up the content of a particular folder. It iterates the contents and recursively deletes underlying folders and files.
    \item \textit{deleteResource()}, a function responsible for deleting individual resources from a \solid{} POD. Following the sequence flow presented on \autoref{fig:lps_rename_resource}, depending on the type of the resource it will either remove it directly or attempt to clean it recursively if the resource is an \textit{LDP-BC}.
    \item \textit{getResource()}, a basic function executing a \texttt{GET} call to obtain a resource content from a \solid{} server.
    \item \textit{copyFile()}, a basic function performing a copy operation on an \textit{LDPR}.
    \item \textit{copyResource()}, a generic method performing a copy operation on a resource. Depending on the type of the resource it either invokes the \textit{copyFile()} directly or, if resource is an \textit{LDP-BC}, it performs a recursive copying.
    \item \textit{renameResource()}, a method responsible for changing the title of the resource inside the \solid{} POD. In that case it simply means changing the absolute path to resource, where the name is the last element in the path. This function is described in detail on \autoref{ssssec:renaming_resources}. The operation involves invocation of several simpler methods from the \textit{FileManager} abstraction.
    \item \textit{updateResource()}, a generic function executing an \texttt{HTTP} \texttt{PUT} request for a particular resource.
    \item \textit{createOrUpdateResource()}, a method used in cases when a resource needs to be updated even if a different resource exists under that path. If a nothing exists under supplied path, resource will be created, if an object exists under particular path then it will be removed first.
    \item \textit{resourceExists()}, a method that executes the \texttt{HTTP} \texttt{GET} call to check if anything exits under specified path. The response is a simple boolean value.
    \item \textit{getFolder()}, a method that parses the contents of a particular folder and returns it as an array of underlying files and folders wrapped into a simple configuration abstraction. This is mainly used a part of any recursive operations involving folders.
    \item \textit{deleteFolderRecursively()}, a method used to execute recursive deletion of a particular folder. This is demonstrated in detail on \autoref{fig:lps_delete_resource} under a conditional block that is executed when resource is a folder.  
    \item \textit{createAccessControlStatement()}, \textit{createAccessControlList}, \textit{updateACL()}, \textit{createACL()}, following methods can be found described in \autoref{sssec:access_control_manager_implementation}, as they relate to interacting with \texttt{ACL} resources.
\end{itemize}

It is important to note that the class is not a singleton in contrast with \textit{AuthenticationManager}. This is due to the fact that all classes are exposed as public and static, this design makes the abstraction generic for many use cases within and outside the bounds of requirements of \lpa{}.

The \solid{} resource within the \lpas{} package is represented by \textit{ResourceConfiguration} abstraction that is a basic required input for most of the operations in \textit{FileManager} that involve execution of \texttt{HTTP} requests. The proceeding \autoref{ssssec:lpas_resource_config_implementation} will provide more details on implementation of this class and the relation to \textit{FileManager}.
 
\subsubsection{Resource Configuration}
\label{ssssec:lpas_resource_config_implementation}

One of the challenges when \lpa{} frontend initially contained the code for \solid{} interaction inside was the lack of any abstraction representing a particular \solid{} resource. There were several refactoring attempts to add basic ES6 classes, but maintaining the codebase was not trivial at all. Therefore, after introducing the \lpas{} package, the implementation of abstractions to represent the \solid{} resources was one of the first challenges. The \autoref{fig:lpas_resource_config_implementation} consist of two main entities:
\begin{enumerate}
    \item \textit{ResourceConfig}, a main class representing \textit{ResourceConfiguration} abstraction. 
    \item \textit{SolidResource}, an interface required for each object representing the \solid{} resource to be conforming to. 
\end{enumerate}

\begin{lstlisting}[label={lst:lpas_resource_type_enum},language=javascript]
enum SolidResourceType {
  Folder = '<http://www.w3.org/ns/ldp#BasicContainer>; rel="type"',
  File = '<http://www.w3.org/ns/ldp#Resource>; rel="type"'
}
\end{lstlisting}

The \textit{SolidResource} interface consist of the following:
\begin{itemize}
    \item \textit{type}, an enumerator property represented on \autoref{lst:lpas_resource_type_enum}. Type is either a \textit{Folder} or a \textit{File}.
    \item \textit{path}, a \texttt{string} property representing a full absolute path excluding the filename itself. The reason why filename is excluded is to simplify the interactions within \textit{FileManager} class and provide more flexibility when operating with resources.
    \item \textit{title}, a \texttt{string} property representing the tile of the resource. The extension of the resource is not included.
    \item \textit{contentType}, an optional \texttt{string} property representing the content type header to be passed when constructing and \texttt{HTTP} request to  manipulate this resource. If value is not provided, a \texttt{text/turtle} extension is used by default.
    \item \textit{body}, an optional \texttt{string} property holding a content of the resource. The property is marked optional because there are cases when an empty folder resource need to be created, from an \lpa{} developer point, he does not need to provide any content to create an empty folder resource.
    \item \textit{isPublic}, an optional \textit{boolean} indicating whether the file is controlled only by the creator, owner or can have public read access. This is closely related to \textit{AccessControlManager} abstraction described in \autoref{sssec:access_control_manager_arch}. The proceeding section will describe the implementation of that abstraction in detail.  
\end{itemize}

The fact that \textit{SolidResource} is represented as the interface allows the objects conforming to eat to be constructed effortlessly and straightforwardly, similar to simply creating a \texttt{dictionary} object. The \textit{ResourceConfig}, on the other hand, wraps the object by providing additional information and functionality on top of the original resource object. The \textit{ResourceConfig} class consist of the following:
\begin{itemize}
    \item \textit{webID}, is a \texttt{string} property. The value should be assigned to the creator or owner of the resource. Within \lpa{} frontend, this value is usually holding the \textit{WebID} of the authenticated platform user.  
    \item \textit{resource}, is an \texttt{object} property conforming to \textit{SolidResource} interface. 
    \item \textit{fullPath}, a method returning a concatenated \texttt{string}, representing an absolute path to a resource.
    \item \textit{fullPathWithAppendix()}, a method returning a concatenated \texttt{string}, representing an absolute path to a resource with a \texttt{'/'} symbol. This is required in cases when an operation needs to be performed on a resource a developer wants to be sure that the absolute path will be constructed correctly for the underlying type. The \textit{folder} resource requires the symbol to be appended when dealing with the construction of \texttt{ACL} files. This will be described in more detail in the proceeding section dedicated to \textit{AccessControlManager} abstraction.
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=5cm]{lpas_resource_config_implementation.png}
\caption{A class diagram generated directly from a TypeScript file, demonstrating implemented \textit{ResourceConfig} class and \textit{SolidResource} interface}
\label{fig:lpas_resource_config_implementation}
\end{figure}


The \textit{FileManager} class is extensively used throughout the whole \lpa{} frontend codebase. The examples below demonstrated various examples of invocations of the \textit{FileManager} abstraction from within the \lpa{} frontend codebase. It is important to note that the provided examples are generic enough to be applied to the development of any \solid{} application supporting the current iteration of \texttt{node-solid-server}.

\subsubsection{An example on creating a resource}

The example below demonstrated a simple use case on how \lpas{} package can be used to create a \solid{} resource using the \textit{FileManager} abstraction. 

\begin{lstlisting}[language=javascript]
const configurationsFolderConfig: ResourceConfig = new ResourceConfig(
        {
          path: rootResourceConfig.fullPath(),
          title: 'configurations',
          type: SolidResourceType.Folder
        },
        webId
      );
      
const response = await StorageFileManager.createResource(configurationsFolderConfig)
\end{lstlisting}

In this particular case, a folder resource \textit{ResourceConfig} class instance is being created named \textit{configurationsFolderConfig}. Afterwards it is being passed to a public static \textit{createResource()} method that creates the resource as described on \autoref{fig:lpas_create_resource}. This concludes the description of the implementation of \textit{FileManager} abstraction. The proceeding section is dedicated to an \textit{AccessControlManager} abstraction, following up the first introduction in the \autoref{sssec:access_control_manager_arch}.


\subsection{Access Control Manager}
\label{sssec:access_control_manager_implementation}

%TODO add citation to acl specification
This subsection provides details on implementation of the \textit{AccessControlManager} abstraction from \autoref{sssec:access_control_manager_arch} section. Despite being called a separate abstraction, it is in fact implemented as a set of additional public static methods inside the \textit{FileManager} abstraction as seen on \autoref{fig:lpas_filemanager_implementation_class} diagram. Essentially every \texttt{ACL} resource is yet another resource represented as \textit{LDPR} in \solid{}. However the functional implication of those resource are more specific and require extra information and functionality to operate with them. That is why it is separated conceptually as a different abstraction but is implemented inside the same class called \textit{FileManager}. 

Referring back to \autoref{fig:lpas_filemanager_implementation_class}, the main methods related to the abstraction are described as follows:
\begin{itemize}
	\item \textit{updateACL()}, a method constructing the array of RDF triples that is later serialized into a \texttt{text/turtle} and send as a body in \texttt{HTTP} \texttt{PUT} request to \solid{} server, replacing the previous resource under that path.
	\item \textit{createACL()}, a method constructing the array of RDF triples that is later serialized into a \texttt{text/turtle} and send as a body in \texttt{HTTP} \texttt{PUT} request to \solid{} server.
	\item \textit{createAccessControlStatement()}, a method constructing the array of RDF triples expressing access control for a particular WebID. 
	\item \textit{createAccessControlList()}, a method assembling an array of access control statements for multiple requested WebIDs using \textit{createAccessControlStatement()}, and as result serializes the array of statements into a raw \texttt{text/turtle} \texttt{string} using \texttt{rdflib}.
\end{itemize}

The functionality implemented by \textit{AccessControlManager} is not conforming to entire Web Access Control specification, since it was not needed and not required to satisfy the \lpa{} requirements. Therefore, methods described earlier such as \textit{updateACL()} and \textit{createACL()} as seen on \autoref{fig:lps_acl_update_flow}, were based on the default \texttt{.acl} files that \texttt{NSS} generates. At the moment of writing this thesis, the default \textit{.acl} files generated by \texttt{NSS v5.2.0} looks as follows:

\begin{listing}[H]    
\begin{minted}[breaklines]{turtle}
@prefix : <#>.
@prefix n0: <http://xmlns.com/foaf/0.1/>.
@prefix n1: <http://www.w3.org/ns/auth/acl#>.
@prefix test: <./>.
@prefix c: </profile/card#>.
 
:owner
    n1:accessTo test:;
    n1:agent c:me;
    n1:default test:;
    n1:mode n1:Control, n1:Read, n1:Write.
:public
n1:accessTo test:; n1:agentClass n0:Agent; n1:default test:; n1:mode n1:Read.
\end{minted}
\caption{An example \texttt{ACL} resource in \texttt{text/turtle} describing access control for a folder} 
\label{lst:acl_file_example}
\end{listing}

As seen on \autoref{lst:acl_file_example}, the example describes access control privileges to a folder named \textit{test}. The first semantic triple contains a subject named \texttt{:owner}, this refers to the WebID of the owner of this \solid{} POD. The predicates of the Owner subject can be described as follows:
\begin{itemize}
	\item \textit{accessTo}, the information resource to which the access is being granted. In this case we are granting access to a folder named \textit{test}
	\item \textit{agent}, a person or an entity to whom the rights are being given. Since this is an owner of the \solid{} pod, the reference is given to himself.
	\item \textit{default}, this is a special predicate that behaves as follows. If the underlying resources have no \texttt{.acl} files specified they will keep referring to a parent resources until it will reach the resource containing the \texttt{.acl} file with \textit{default} predicate. In this case the statement says that the underlying resources without explicitly set \textit{.acl} files will have the same access control rights as the \textit{test} folder.
	\item \textit{mode}, a predicate describing the access control modes. In this case the object are defined as follows: 
		\subitem \textit{Control}, a semantic object describing full read and write access to an \texttt{ACL} of the resource.
		\subitem \textit{Read}, a semantic object giving a full read access to a resource.
		\subitem \textit{Write}, a semantic object giving a full write access to a resource.
\end{itemize}

On the other hand, the subject named \textit{public}, only has an ability to \textit{Read} the folder and its content. The \textit{public} subject is just a generic simplification for cases when there is no need to explicitly set specific WebIDs, however, using \texttt{ACL} easily allows to list specific users as well, giving a lot of flexibility to have a very complex access control privileges setup per any resource in a \solid{} POD. As mentioned earlier, the ability to manipulate access control to any resource and own your own data is one of the core benefits proposed by \solid{} project. 

\subsubsection{Access Control Configuration}

Aside from the main \textit{AccessControlManager} abstraction, as demonstrated on \autoref{chap:num_1}, the original \textit{ResourceConfig} class from \textit{FileManager} required to be extended by introducing several subclasses called:
\begin{itemize}
	\item \textit{AccessControlConfig}, a subclass of \textit{ResourceConfig} that adds a property listing available control modes to a resource for specified WebID, and adds methods to construct the proper absolute path to a resource. The only difference between those methods and methods described in \autoref{ssssec:lpas_resource_config_implementation} such as \textit{fullPath()} and \textit{fullPathWithAppending()}, is that the hardcoded keyword \texttt{.acl} for files and hardcoded keyword \texttt{/.acl} for folder are being appended.
	\item \textit{AccessControlStatementConfig}, a subclass of \textit{AccessControlConfig}, contains additional references to \texttt{rdflib} nodes to simplify construction of \texttt{ACL} triples in \textit{AccessControlManager} abstraction.
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=4cm]{lpas_access_control_config_imlementation.png}
\caption{A class diagram generated directly from a TypeScript file, demonstrating implemented \textit{AccessControlConfig} and \textit{AccessControlStatementConfig} extending \textit{ResourceConfig}}
\label{fig:lpas_access_control_config_imlementation}
\end{figure}

\subsubsection{An example on creating an \texttt{ACL} file for a \solid{} resource}

The example below demonstrated a simple use case on how \lpas{} package can be used to create an \texttt{ACL} file for a \solid{} resource using the \textit{FileManager} abstraction. 

\begin{listing}[H]    
\begin{minted}[breaklines]{javascript}
const configurationsAclResourceConfig: AccessControlConfig = new AccessControlConfig(
  {
    ...configurationsFolderConfig.resource,
    isPublic: true
  },
  [AccessControlNamespace.Read, AccessControlNamespace.Write],
  webId
);

const response = await StorageFileManager.updateACL(
  configurationsAclResourceConfig
);
\end{minted}
\caption{An example ES6 code on creating ACL files for \solid{} resource in \lpa{} frontend} 
\label{lst:acl_creation_lpa_example}
\end{listing}

In this case, a folder resource is expressed as a \textit{ResourceConfig} class instance under \textit{configurationsFolderConfig} constant and \textit{configurationsAclResourceConfig} constant is created based on it to express and \texttt{ACL} file. Using the ES6 \texttt{spread} operator we populate the description of the folder resource as follows '\texttt{...configurationsFolderConfig.resource}'. Afterwards, the access control modes are supplied in an array giving the ability to \textit{Read} and \textit{Write} to that resource to anyone by default. In the last step the specify the webId of the owner of the resource and the \texttt{ACL} file to be created and supply the constructed \textit{AccessControlConfig} into \textit{updateACL()} method that is demonstrated in detail on this sequence \autoref{fig:lps_acl_update_flow}.

To sum up, the section provided an overview of three main abstractions inside \lpas{} package. The \textit{AuthenticationManager} used as a main class to deal with WebID based authentications for \lpa{} platform. The \textit{FileManager}, responsible for managing all \texttt{HTTP} requests to manipulate resources in a \solid{} resource. \textit{AccessControlManager} abstraction that significantly simplified the interactions with \solid{} inside \lpa{} frontend significantly and gave an ability to implement more advanced access control related features to configure the published \lpa{} visualizers. This will be demonstrated in detail in \autoref{sssec:lpas_storage_frontend_implementation}. The consequitive section will describe the \lpas{} Ontology originally described in \autoref{fig:lps_acl_update_flow}, its implementation and hosting.

\section{Hosting Storage Ontology}

This section is going to continue the details on implementation of the \lpas{} ontology, firstly described in \autoref{ssec:lpas_application_ontology_arch}. As mentioned earlier, the intent to design the ontology was to better utilize the benefits of \solid{} and the ways in which every entity is represented as an RDF resource. The ontology itself was implemented using a set of open source tools that will be described in the first part of this section. 

\subsection{Preliminaries}

There are two main open-source frameworks that were used to implement and publish the \lpas{} ontology:
\begin{itemize}
	\item \texttt{Protégé} \cite{noy2003protege}, is an open-source ontology editing framework developed at Stanford University and written in Java programming language. It provides an intuitive graphic user interface for defining and developing ontologies. The version of the software used at the moment of implementing the ontology is \texttt{v5.5.0}.
	\item \texttt{Ontoology} \cite{alobaid2015ontoology}, is an open-source software solution for collaborative development of ontologies on GitHub. However, in the scope of implementing \lpas{} ontology it was mainly chosen for its additional features such as an ability to publish ontologies under permanent \texttt{w3id.org} url, an ability to host the ontology as a static \texttt{HTML} under GitHub Pages. 
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{misc_ontology_visualizer.png}
\caption{Example UI of \texttt{Protégé} ontology editor at \textit{Active Ontology} tab.}
\label{fig:misc_ontology_visualizer}
\end{figure}

\subsection{Using \texttt{Protégé}}

After defining the main entities and designing the hierarchical structure of the ontology in \autoref{ssec:lpas_application_ontology_arch}, the ontology was implemented using \texttt{Protégé} ontology editor. The editor allows defining the ontology entities by specifying them under:
\begin{itemize}
	\item \textit{Classes}, tab represents the \textit{asserted} and \textit{inferred} class hierarchies as a tree, where each node represents a particular class. The \textit{asserted} class view is a default and primary navigation device for browsing class hierarchies in \textit{Protégé}, the \textit{inferred} classes view on the other hand differs from \textit{asserted} by requiring a reasoner to be setup to render the complete hierarchy view. If no reasoner is provided the \textit{inferred} classes view will be empty.
	\item \textit{Object properties} tab,  represents the graphical user interface to create and define relations between instances of the classes. The view under that tab is similar to the \textit{Classes} tab, the properties are represented as a tree with nodes identifying individual object property. For instance, each \textit{VisualizerConfiguration} can be filtered by a \textit{FilteredConfiguration}, this relation can be expressed by defining an object property calls \textit{filteredBy}.
	\item \textit{Data properties} tab, represents the graphical user to create and define relations between instances of classes and RDF literals or datatypes. For instance, a \textit{VisualizerConfiguration} class has a \textit{backgroundColor} data property which is a \textit{String} datatype. 
\end{itemize}

The resulting ontology created in \texttt{Protégé} was represented as an \texttt{.owl} which is a format for Web Ontology Language described earlier in \autoref{sssec:using_web_ontology_language}. The following subsection will describe the process of publishing the ontology using the \textit{Ontoology} software. 

\subsection{Using \textit{Ontoology}}

The \textit{Ontoology} itself is an open source project that can be instantiated and configured manually, it is however, also available as a standalone running instance \footnote{http://ontoology.linkeddata.es}. The publishing of the \lpas{} Ontology was done using the available instance instead of manually configuring one, this greatly reduced the development time needed to publish and host the vocabulary to be used in \lpa{} frontend.

The initial configuration or startup guide to \textit{Ontology} consist of the following steps: 
\begin{enumerate}
	\item \textit{Setup a GitHub repository}, an exported \texttt{.owl} file from \texttt{Protégé} was hosted on a regular public GitHub repository \footnote{https://github.com/aorumbayev/linkedpipesapplicationsontology} and placed at the root.
	\item \textit{Add repository to Ontoology}, add the repository by name into Ontology and press \textit{Watch this repo} button. This is pretty much the last step involving any manual work. The following steps are all invoked in automated fashion, demonstrating the full list of benefits provided by this software.
	\item \textit{Merge initial PR from Ontoology}, once repository is connected, an automated PR will be opened that will contain a following list of elements:
	\begin{enumerate}
		\item Diagrams, a folder with pre-generated class hierarchy visualizations of the ontology.
		\item Documentation, an automatically generated ontology documentation hosted on GitHub Pages on the same repository, and available at \textit{w3id.org} permanent url redirecting users to GitHub Pages.
		\item Evaluation report, \textit{Ontoology} generates a report that checks various aspects of the implementation of the ontology, providing hints when, for instance, some parts in description of an entity is missing.
		\item JSON-LD, an original \texttt{.owl} file is automatically converted into a JSON-LD file.  
	\end{enumerate}
\end{enumerate}

\begin{figure}[h]
\centering
\fcolorbox{black}{white}{\includegraphics[width=0.8\linewidth]{misc_ontoology_ui.png}}
\caption{UI of Ontoology displaying the processed repository with \lpas{} Ontology.}
\label{fig:misc_ontoology_ui}
\end{figure}

To sum up, the \lpas{} ontology was implemented using two open-source frameworks called \texttt{Protégé} and \texttt{Ontoology}. The first tool was used as an editor to implement the ontology designed in \autoref{ssec:lpas_application_ontology_arch}. The second tool was used to publish and host application. The detailed documentation will be mentioned in \autoref{chap:num_8} and is also available at \url{http://w3id.org/def/lpapps}. 

\section{Storage Frontend}

The following section will continue the \autoref{ssec:lpas_storage_component_design} by providing the details on implementation of individual components interacting with \solid{} POD. 

\subsection{Preliminaries}

In order to simplify understanding of this section, it is important to recap the conventions and specifics of \lpa{} frontend implementation by providing some extended details, as they were strictly taken into consideration while developing \lpas{} components inside the \lpa{} frontend codebase.

As mentioned earlier in \TODO{add reference to introduction chapter}, the frontend provides a way for the user to interact with the \lpa{}. As demonstrated on the \autoref{fig:lpa_frontend_architecture}, frontend uses Redux and React as a main frameworks for building the components and managing states.

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{lpa_frontend_architecture.png}
\caption{General architecture of Redux store and React components within \emph{frontend}}
\label{fig:lpa_frontend_architecture}
\end{figure}

The main entities displayed on \ref{fig:lpa_frontend_architecture} can be described as follows:

\begin{itemize}
    \item \textit{React Component}, a JavaScript class or function that optionally accepts inputs, i.e., properties(props), and returns a React element that describes how a section of the UI (User Interface) should appear. 
    \item \textit{Redux}, represents a container that stores various states of the web application per individual webpage.
        \begin{itemize}
            \item \textit{State}, refers to the single state value that is managed by the store and returned by \texttt{getState()}. It represents the entire state of a Redux application, which is often a deeply nested object.
            \item \textit{Reducer}, specifies how the application's state changes in response to actions sent to the store.
            \item \textit{Actions}, are payloads of information that send data from your application to your store. They are the only source of information for the store. It is invoked by sending them to the store using \texttt{store.dispatch()}.
            \item \textit{Selector}, is simply any function that accepts the Redux store state (or part of the state) as an argument, and returns data that is based on that state.
        \end{itemize}
\end{itemize}

\subsubsection{Frontend code structure}
\label{ssssec:lpa_frontend_code_structure}

The implementation of the \lpa{} frontend is located at the \texttt{src/frontend} path at official \lpa{} repository \footnote{https://github.com/linkedpipes/applications}  and structured as follows:

\begin{itemize}
    \item \textit{constants} - contains all constants used throughout the frontend component implementation.
    \item \textit{utils} - contains various handy utility classes, variables, and methods.
    \item \textit{ducks} - contains all Redux reducers, actions and selectors. 
    \item \textit{layouts} - contains global setup for various components as well as the specification for the MaterialDesign theme used in the project.
    \item \textit{components} - contains all \texttt{.jsx} components, visualizers and various UI elements implementations not related to interactions with \solid{}.
    \item \textit{containers} - contains complex layouts for specific web-pages of the web app not related to interactions with \solid{}. Each folder is named after individual webpage. 
    \item \textit{storage} - contains all contributions and implementations made within the scope of \lpas{} project. Has a substructure mimicking the global folder structure to improve code maintainability and signify the difference between implementations of \lpa{} and \lpas{}.
\end{itemize}

\subsection{Storage folder structure}

As mentioned in \autoref{ssssec:lpa_frontend_code_structure}, let us describe the internals of \textit{storage} folder inside \lpa{} frontend codebase. 

\begin{itemize}
    \item \textit{utils} - contains various handy utility classes, variables, and methods.
    \item \textit{ducks} - contains all Redux reducers, actions and selectors. 
    \item \textit{models} - contains global setup for various components as well as the specification for the MaterialDesign theme used in the project.
    \item \textit{components} - contains all \texttt{.jsx} components, visualizers and various UI elements implementations not related to interactions with \solid{}.
    \item \textit{containers} - contains complex layouts for specific web-pages of the web app not related to interactions with \solid{}. Each folder is named after individual webpage. 
\end{itemize}

\begin{listing}[H]    
\begin{minted}[breaklines]{json}
{
  "@graph": [
    {
      "@context": "https://w3id.org/def/lpapps",
      "@type": "VisualizerConfiguration",
      "applicationData": "undefined",
      "author": {
        "@id": "https://w3id.org/profile/card#me"
      },
      "backgroundColor": "#671570",
      "configurationId": "1afbe0f2-3a58-424e-91ec-6a41ae8717b3",
      "endpoint": "chord",
      "etlExecutionIri": "{example execution iri}",
      "filteredBy": {
        "@id": "_:b0"
      },
      "graphIri": "{example iri}",
      "published": "2019-11-24T16:27:51.043Z",
      "title": "Chord application",
      "visualizerType": "CHORD"
    }
  ]
}
\end{minted}
\caption{An example \lpa{} configuration in \textit{JSON-LD} format} 
\label{lst:acl_creation_lpa_example}
\end{listing}

\section{Implementing requirements}