\chapter{Implementation}
\label{chap:num_5}

The following chapter is going to cover the implementation of \lpas{} package, the frontend components as well as the ontology. The first part of the chapter dedicated to the implementation of the package will provide a detailed overview of the decisions made on the development stack, the main challenges invoked in refactoring the original \lpa{} codebase, and making the \solid{} related functionality more generic. The frontend components section will dive deeper into the implementation of the mocks provided in \autoref{chap:num_4}, main decisions, and challenges while developing under React. The ontology section \TODO{link} will describe how the designed \lpas{} vocabulary was converted into a \texttt{.owl} file, converted into \texttt{.jsonld} Schema and later integrated into the \lpa{} frontend. Lastly, an overview of the implementation results will be presented by reiterating over the defined \lpa{} requirements and how they were satisfied by the implementation.
 
\section{Storage Package}

The initial implementation of \lpa{} frontend was written in \texttt{JavaScript ES6} \footnote{http://es6-features.org} and \texttt{React} framework. The development stack also included tools such as \texttt{Babel} \footnote{https://babeljs.io} compiler and \texttt{Webpack} \footnote{https://webpack.js.org} package bundler. As the amount of features and functionality to cover was increasing, the decision was made to separate the \solid{} storage related functionality into a separate \texttt{npm} package and call it \lpas{}. This section will provide an overview of preliminaries chosen for the implementation of \lpas{} package as well as the specifics of implementations of each abstraction defined in \autoref{ssec:storage}. 

\subsection{Preliminaries}

As briefly mentioned earlier, there several main libraries used inside the \lpas{} package:

\begin{itemize}
    \item \texttt{rdflib} is a low-level RDF library, that mainly provides the functionality to Read and Write RDF in many popular formats, a querying store and an ability to use SPARQL queries.
    \item \texttt{solid-auth-client}, a browser library that implements \solid{} specifications for providing authentication. This is the main library used to enable the authentication into \lpa{} platform.    
%    Todo add ref for testing chapter
    \item \texttt{ava.js}, is a simple JavaScript unit tests runner with TypeScript support. More on testing will be described in a Testing chapter. It is important to note that proper unit testing was one of the other major factors for splitting the \solid{} functionality into a separate package. Easier code maintainability, along with features of TypeScript, significantly improved test-driven development of the package. 
    \item \texttt{istanbul.js}, a test coverage tool used along with \texttt{ava.js}. The library provides a convenient command-line interface that was used for improving Continuous Integration and Delivery jobs. More details on CI and CD are covered in the testing chapter.
\end{itemize}

Due to the complexity of the usage of the stated libraries, specifically \texttt{rdflib}, having an environment and a language that provides a fully-featured object-oriented programming and static type-checking would directly affect the code maintainability and usage. Hence, the codebase of \lpas{} was implemented using \texttt{TypeScript} \footnote{https://www.typescriptlang.org}. TypeScript is a strict syntactical superset of JavaScript that provides optional static typing and better object-oriented programming capabilities.  

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{lpas_implementation_transpilation_diagram.png}
\caption{A diagram demonstrating the process of transpilation of \lpas{} package and bundling \lpa{} frontend with Webpack}
\label{fig:lpas_implementation_transpilation_diagram}
\end{figure}

As demonstrated on \autoref{fig:lpas_implementation_transpilation_diagram}, integrating the package into the \lpa{} codebase was done using the TypeScript compiler that allows transpilation into ES6 compatible Javascript syntax. The package, as well as the rest of the \lpa{} codebase,  is later bundled into a set of static assets using Webpack. The assets mainly consist of a set of media files such as \texttt{.png} and \texttt{.svg} files and a large \texttt{.js} file that contain the whole \lpa{} frontend. One of a few disadvantages with that approach is that the initial loading of the frontend might take a few seconds to load in the browser. Afterward, the interaction with the platform is seamless and does not involve any additional loading.

\subsubsection{Project structure}

The structure of the \lpas{} package is simple and straightforward and can be demonstrated as follows:

\begin{lstlisting}
- build       # Transpiled JS code    
- markdown    # Markdown assets
- src         # Root project folder
  - lib       # Main library codebase
    - common  # Utilities and helper functions
   	- ...     # TypeScript tests and core abstractions
  - types     # Custom user-defined type definitions
- docs        # Static html with library documentation
_ ...         # Readme and various configuration files
\end{lstlisting}

The proceeding sections will describe the individual abstractions mentioned in \autoref{ssec:storage} section.

\subsection{Authentication Manager}

This section will continue the architectural description of the Authentication manager described in \autoref{sssec:authentication_manager}, describe the implementation, and provide examples of how the abstraction is used inside \lpa{}.

The \textit{AuthenticationManager} is a Singleton class, instantiated only once and utilised both in the package itself as well as being invoked from \lpa{} frontend codebase. The reason for the class being implemented as a singleton is due to the fact that it wraps the functionality of \texttt{solid-auth-client} library. Aside from providing the WebID authentication,  \texttt{solid-auth-client} implements a WebID OIDC specific \textit{fetch} functionality. The \textit{FETCH API} is originally a JavaScript API that provides an ability to send asynchronous \texttt{HTTP} calls. The implementation in \texttt{solid-auth-client}, is based on \texttt{isomorpic-fetch}, which is a third party framework that implements the \textit{Fetch API} both for browsers and node.js. Hence, the abstraction is used for:
\begin{itemize}
    \item Authentication, and ability to track the user session with callbacks. 
    \item Sending \texttt{HTTP} calls to \solid{} server.
\end{itemize}


\begin{figure}[h]
\centering
\includegraphics[width=6cm]{lpas_authentication_class.png}
\caption{A class diagram generated directly from a TypeScript file, demonstrating an implemented \textit{AuthenticationManager} abstraction}
\label{fig:lpas_authentication_class}
\end{figure}


In other words, once the client is logged in the \solid{} app, consecutive interactions are performed via \textit{fetch} function that is conveniently wrapped in the \textit{AuthenticationManager} abstraction.

As demonstrated on \autoref{fig:lpas_authentication_class}, the class consist of a set of public methods described as follows:
\begin{itemize}
    \item \textit{getInstance()}, this public method returns a singleton instance to an AuthenticationManager.
    \item \textit{fetch()}, a wrapper redirecting the call to \texttt{solid-auth-client} fetch method.
    \item \textit{login()}, a wrapper redirecting the call to \texttt{solid-auth-client} login method.
    \item \textit{trackSession()}, a method with asynchronous callback notifying the listener when a logout or login operation is performed.
    \item \textit{currentSession()}, a method returning the instance of a \texttt{solid-auth-client} Session object that contains relevant information about the authenticated user and his WebID. 
\end{itemize}

Referring back to \autoref{fig:lps_authentication_sequence_diagram}, there are several places in \lpa{} codebase where the \textit{AuthenticationManager} is invoked directly. The implementation of React components will be covered in the proceeding section, but the invocation of the abstraction itself can be described as follows:
\begin{itemize}
    \item \textit{Component layouts} are special high-level react containers that wrap every other container inside \lpa{} frontend. They are differentiated by \textit{public} and \textit{private}. The \textit{private} components reactively monitor the authenticated session of a user and redirect them back to the authentication screen whenever the value of the session becomes \texttt{undefined}. It is important to note that the session object from \textit{AuthenticationManger} is duplicated in \lpa{} frontend as a Redux state. Therefore, any changes in the original session object are reflected on that state and triggers re-rendering of layout components. 
    \item \textit{Authentication component functions}, are the functions being invoked when user attempts to perform the authentication. In other words, this is the input that triggers the flow demonstrated earlier on \autoref{fig:lps_authentication_sequence_diagram}.
    \item \textit{The App router}, the main class in \lpa{} that serves as an entry point and utilizing the \texttt{react-router} \footnote{https://www.npmjs.com/package/react-router} package, contains a function that invokes the \textit{trackSession()} method in \textit{AuthenticationManager}. This directly links to the session object and updates the changes from original session to internal Redux state.
\end{itemize}

The usage of both \textit{currentSession()} and \textit{login()} methods from \textit{AuthenticationManager} can be observed below:
\begin{lstlisting}[language=JavaScript]
login = async (idp, callbackUri) => {
    const session = await AuthenticationManager.currentSession();
    if (!session)
      await AuthenticationManager.login(idp, {
        storage: localStorage
      });
    else {
      Log.info(`Logged in as ${session.webId}`);
      return session;
    }
};
\end{lstlisting}

To sum up, the \textit{AuthenticationManager} is a simple and straightforward singleton abstraction that wraps the \texttt{solid-auth-client} library and only necessary functions from the wrapped library to be used inside \lpas{} frontend. The examples of invocation from within the \lpas{} package are limited to directly calling the \textit{fetch()} method whenever an \texttt{HTTP} request is assembled and needs to be executed, more details on that will be described in a section dedicated to \textit{FileManager} abstraction.  


%\subsubsection{Creating resources}
%\subsubsection{Reading resources}
%\subsubsection{Renaming resources}
%\subsubsection{Deleting resources}

\subsection{File Manager}

In this subsection, we will continue on the \textit{FileManager} abstraction described in \autoref{sssec:file_manager}, provide the specifics on implementation as well as a detailed overview of each method inside the abstraction.  

\begin{figure}[h]
\centering
\includegraphics[width=5cm]{lpas_implementation_file_manager_diagram.png}
\caption{A class diagram generated directly from a TypeScript file, demonstrating an implemented \textit{FileManager} abstraction}
\label{fig:lpas_filemanager_implementation_class}
\end{figure}

Similar to the \textit{AuthenticationManager}, the \textit{FileManager} abstraction is implemented as a TypeScript class providing a set of public static methods. It is responsible for all core \textit{CRUD} operations with \solid{} resources. It is important to note that all \texttt{HTTP} requests to \solid{} server are made using the \textit{fetch()} method invoked via \textit{AuthenticationManager}. In other words \textit{FileManager} relies on \textit{AuthenticationManager} when performing \texttt{HTTP} requests. To follow up a class representation on \autoref{fig:lpas_filemanager_implementation_class}, the methods can be described as follows:
\begin{itemize}
%    \item \textit{updateACL}, a function is responsible for applying changes to existing \texttt{ACL} files. For instance, changes access privileges for a specific user, or adding a new member to access a resource by his WebID. This function is closely related to \textit{Access Control Manager}
%    \item \textit{createACL}, a function is responsible for creating a new \texttt{Acce}
    \item \textit{createResource()}, a function is responsible for creating new \solid{} resources. 
    \item \textit{deleteFolderContents()}, a function is mainly used for cleaning up the content of a particular folder. It iterates the contents and recursively deletes underlying folders and files.
    \item \textit{deleteResource()}, a function responsible for deleting individual resources from a \solid{} POD. Following the sequence flow presented on \autoref{fig:lps_rename_resource}, depending on the type of the resource it will either remove it directly or attempt to clean it recursively if the resource is an \textit{LDP-BC}.
    \item \textit{getResource()}, a basic function executing a \texttt{GET} call to obtain a resource content from a \solid{} server.
    \item \textit{copyFile()}, a basic function performing a copy operation on an \textit{LDPR}.
    \item \textit{copyResource()}, a generic method performing a copy operation on a resource. Depending on the type of the resource it either invokes the \textit{copyFile()} directly or, if resource is an \textit{LDP-BC}, it performs a recursive copying.
    \item \textit{renameResource()}, a method responsible for changing the title of the resource inside the \solid{} POD. In that case it simply means changing the absolute path to resource, where the name is the last element in the path. This function is described in detail on \autoref{ssssec:renaming_resources}. The operation involves invocation of several simpler methods from the \textit{FileManager} abstraction.
    \item \textit{updateResource()}, a generic function executing an \texttt{HTTP} \texttt{PUT} request for a particular resource.
    \item \textit{createOrUpdateResource()}, a method used in cases when a resource needs to be updated even if a different resource exists under that path. If a nothing exists under supplied path, resource will be created, if an object exists under particular path then it will be removed first.
    \item \textit{resourceExists()}, a method that executes the \texttt{HTTP} \texttt{GET} call to check if anything exits under specified path. The response is a simple boolean value.
    \item \textit{getFolder()}, a method that parses the contents of a particular folder and returns it as an array of underlying files and folders wrapped into a simple configuration abstraction. This is mainly used a part of any recursive operations involving folders.
    \item \textit{deleteFolderRecursively()}, a method used to execute recursive deletion of a particular folder. This is demonstrated in detail on \autoref{fig:lps_delete_resource} under a conditional block that is executed when resource is a folder.  
    \item \textit{createAccessControlStatement()}, \textit{createAccessControlList}, \textit{updateACL()}, \textit{createACL()}, following methods can be found described in \autoref{sssec:access_control_manager_implementation}, as they relate to interacting with \texttt{ACL} resources.
\end{itemize}

It is important to note that the class is not a singleton in contrast with \textit{AuthenticationManager}. This is due to the fact that all classes are exposed as public and static, this design makes the abstraction generic for many use cases within and outside the bounds of requirements of \lpa{}.

The \solid{} resource within the \lpas{} package is represented by \textit{ResourceConfiguration} abstraction that is a basic required input for most of the operations in \textit{FileManager} that involve execution of \texttt{HTTP} requests. The proceeding \autoref{ssssec:lpas_resource_config_implementation} will provide more details on implementation of this class and the relation to \textit{FileManager}.
 
\subsubsection{ResourceConfiguration}
\label{ssssec:lpas_resource_config_implementation}

One of the challenges when \lpa{} frontend initially contained the code for \solid{} interaction inside was the lack of any abstraction representing a particular \solid{} resource. There were several refactoring attempts to add basic ES6 classes, but maintaining the codebase was not trivial at all. Therefore, after introducing the \lpas{} package, the implementation of abstractions to represent the \solid{} resources was one of the first challenges. The \autoref{fig:lpas_resource_config_implementation} consist of two main entities:
\begin{enumerate}
    \item \textit{ResourceConfig}, a main class representing \textit{ResourceConfiguration} abstraction. 
    \item \textit{SolidResource}, an interface required for each object representing the \solid{} resource to be conforming to. 
\end{enumerate}

\begin{lstlisting}[label={lst:lpas_resource_type_enum},language=javascript]
enum SolidResourceType {
  Folder = '<http://www.w3.org/ns/ldp#BasicContainer>; rel="type"',
  File = '<http://www.w3.org/ns/ldp#Resource>; rel="type"'
}
\end{lstlisting}

The \textit{SolidResource} interface consist of the following:
\begin{itemize}
    \item \textit{type}, an enumerator property represented on \autoref{lst:lpas_resource_type_enum}. Type is either a \textit{Folder} or a \textit{File}.
    \item \textit{path}, a \texttt{string} property representing a full absolute path excluding the filename itself. The reason why filename is excluded is to simplify the interactions within \textit{FileManager} class and provide more flexibility when operating with resources.
    \item \textit{title}, a \texttt{string} property representing the tile of the resource. The extension of the resource is not included.
    \item \textit{contentType}, an optional \texttt{string} property representing the content type header to be passed when constructing and \texttt{HTTP} request to  manipulate this resource. If value is not provided, a \texttt{text/turtle} extension is used by default.
    \item \textit{body}, an optional \texttt{string} property holding a content of the resource. The property is marked optional because there are cases when an empty folder resource need to be created, from an \lpa{} developer point, he does not need to provide any content to create an empty folder resource.
    \item \textit{isPublic}, an optional \textit{boolean} indicating whether the file is controlled only by the creator, owner or can have public read access. This is closely related to \textit{AccessControlManager} abstraction described in \autoref{sssec:access_control_manager_arch}. The proceeding section will describe the implementation of that abstraction in detail.  
\end{itemize}

The fact that \textit{SolidResource} is represented as the interface allows the objects conforming to eat to be constructed effortlessly and straightforwardly, similar to simply creating a \texttt{dictionary} object. The \textit{ResourceConfig}, on the other hand, wraps the object by providing additional information and functionality on top of the original resource object. The \textit{ResourceConfig} class consist of the following:
\begin{itemize}
    \item \textit{webID}, is a \texttt{string} property. The value should be assigned to the creator or owner of the resource. Within \lpa{} frontend, this value is usually holding the \textit{WebID} of the authenticated platform user.  
    \item \textit{resource}, is an \texttt{object} property conforming to \textit{SolidResource} interface. 
    \item \textit{fullPath}, a method returning a concatenated \texttt{string}, representing an absolute path to a resource.
    \item \textit{fullPathWithAppendix()}, a method returning a concatenated \texttt{string}, representing an absolute path to a resource with a \texttt{'/'} symbol. This is required in cases when an operation needs to be performed on a resource a developer wants to be sure that the absolute path will be constructed correctly for the underlying type. The \textit{folder} resource requires the symbol to be appended when dealing with the construction of \texttt{ACL} files. This will be described in more detail in the proceeding section dedicated to \textit{AccessControlManager} abstraction.
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=5cm]{lpas_resource_config_implementation.png}
\caption{A class diagram generated directly from a TypeScript file, demonstrating implemented \textit{ResourceConfig} class and \textit{SolidResource} interface}
\label{fig:lpas_resource_config_implementation}
\end{figure}


The \textit{FileManager} class is extensively used throughout the whole \lpa{} frontend codebase. The examples below demonstrated various examples of invocations of the \textit{FileManager} abstraction from within the \lpa{} frontend codebase. It is important to note that the provided examples are generic enough to be applied to the development of any \solid{} application supporting the current iteration of \texttt{node-solid-server}.

\subsubsection{An example on creating a resource}

The example below demonstrated a simple use case on how \lpas{} package can be used to create a \solid{} resource using the \textit{FileManager} abstraction. 

\begin{lstlisting}[language=javascript]
const configurationsFolderConfig: ResourceConfig = new ResourceConfig(
        {
          path: rootResourceConfig.fullPath(),
          title: 'configurations',
          type: SolidResourceType.Folder
        },
        webId
      );
      
const response = await StorageFileManager.createResource(configurationsFolderConfig)
\end{lstlisting}

In this particular case, a folder resource \textit{ResourceConfig} class instance is being created named \textit{configurationsFolderConfig}. Afterwards it is being passed to a public static \textit{createResource()} method that creates the resource as described on \autoref{fig:lpas_create_resource}. This concludes the description of the implementation of \textit{FileManager} abstraction. The proceeding section is dedicated to an \textit{AccessControlManager} abstraction, following up the first introduction in the \autoref{sssec:access_control_manager_arch}.


\subsection{Access Control Manager}
\label{sssec:access_control_manager_implementation}

%TODO add citation to acl specification
This subsection provides details on implementation of the \textit{AccessControlManager} abstraction from \autoref{sssec:access_control_manager_arch} section. Despite being called a separate abstraction, it is in fact implemented as a set of additional public static methods inside the \textit{FileManager} abstraction as seen on \autoref{fig:lpas_filemanager_implementation_class} diagram. Essentially every \texttt{ACL} resource is yet another resource represented as \textit{LDPR} in \solid{}. However the functional implication of those resource are more specific and require extra information and functionality to operate with them. That is why it is separated conceptually as a different abstraction but is implemented inside the same class called \textit{FileManager}. 

Referring back to \autoref{fig:lpas_filemanager_implementation_class}, the main methods related to the abstraction are described as follows:
\begin{itemize}
	\item 
\end{itemize}


\section{Hosting Storage Ontology}


\section{Storage Frontend}

\begin{lstlisting}[language=json]
{
  "@graph": [
    {
      "@id": "https://w3id.org/def/lpapps",
      "@type": "https://w3id.org/def/lpapps#VisualizerConfiguration",
      "https://w3id.org/def/lpapps#applicationData": "undefined",
      "https://w3id.org/def/lpapps#author": {
        "@id": "https://w3id.org/profile/card#me"
      },
      "https://w3id.org/def/lpapps#backgroundColor": "#671570",
      "https://w3id.org/def/lpapps#configurationId": "1afbe0f2-3a58-424e-91ec-6a41ae8717b3",
      "https://w3id.org/def/lpapps#endpoint": "chord",
      "https://w3id.org/def/lpapps#etlExecutionIri": "http://localhost:8080/resources/executions/1574612566772-0-2f47c643-55c0-419d-9313-1381cec14b1d",
      "https://w3id.org/def/lpapps#filteredBy": {
        "@id": "_:b0"
      },
      "https://w3id.org/def/lpapps#graphIri": "https://applications.linkedpipes.com/graph/84b34afd-6990-411a-920e-cb402b29797f-16dd6a86-2743-42cb-aea7-368b14aa0eff",
      "https://w3id.org/def/lpapps#published": "2019-11-24T16:27:51.043Z",
      "https://w3id.org/def/lpapps#title": "Chord application",
      "https://w3id.org/def/lpapps#visualizerType": "CHORD"
    }
  ]
}
\end{lstlisting}

\section{Implementing requirements}